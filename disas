#!/usr/bin/env bash
ESC=$'\x1b'
GRAY="$ESC[38;5;238m"
BROWN="$ESC[38;2;117;113;94m"
RED="$ESC[38;2;249;38;114m"
LIGHTGREEN="$ESC[38;2;166;226;46m"
ORANGE="$ESC[38;2;237;145;17m"
BLUE="$ESC[38;2;0;170;255m"
PURPLE="$ESC[38;2;205;49;222m"
GREEN="$ESC[38;2;49;181;49m"
DARKGREEN="$ESC[38;2;29;69;40m"
BOLD="$ESC[1m"
OFF="$ESC[0m"


path="$1"
if [[ ! -e "$path" ]]; then
	path="$(which "$1")"
	if [[ -z "$path" ]]; then
		line="$(ldconfig -p | grep -P "^\t$1(\.\d+)* \(" | head -1)"
		if [[ "$line" =~ ^.*" => "(.*)$ ]]; then
			path="${BASH_REMATCH[1]}"
		else
			echo "disas: $1: not found"
			exit 1
		fi
	fi
fi
shift


BAR="$(yes | tr -d "\n" | head -c $(($(tput cols) - 8)) | sed s/y/─/g)"

objdump \
	--disassemble \
	--disassembler-color=color \
	--demangle \
	-Mintel \
	"$path" \
	"$@" \
| {
	read -r line
	read -r line
	file_format="$(<<<"$line" sed "s/.*file format //")"
	printf "$GRAY───────┬$BAR\n"
	printf "$GRAY       │$OFF Disassembly: $BOLD%s$OFF $BROWN(%s)\n" "$path" "$file_format"

	need_newline_before_symbol=0

	while read -r line; do
		if [[ "$line" =~ ^[0-9a-f]{16}\ \<(.*)\>:$ ]]; then
			if [[ $need_newline_before_symbol -eq 1 ]]; then
				echo "$GRAY       │"
			fi

			symbol_name="${BASH_REMATCH[1]}"

			if [[ "$symbol_name" =~ ^(.*[^@])(@[A-Za-z0-9_.@]+)(.*)$ ]]; then
				symbol_name="${BASH_REMATCH[1]}$DARKGREEN${BASH_REMATCH[2]}$LIGHTGREEN${BASH_REMATCH[3]}"
			fi
			if [[ "$symbol_name" =~ ^(.*)([+-]"0x"[0-9a-f]+)$ ]]; then
				symbol_name="${BASH_REMATCH[1]}$PURPLE${BASH_REMATCH[2]}"
			fi
			printf "$GRAY       │ $LIGHTGREEN%s$OFF\n" "$symbol_name"

			declare -A labels
			lines=()
			counter=1
			while read -r line && [[ -n "$line" ]]; do
				line="${line//$ESC[32m/$GREEN}"
				line="${line//$ESC[33m/$ORANGE}"
				line="${line//$ESC[34m/$BLUE}"
				line="${line//$ESC[35m/$PURPLE}"

				lines+=("$line")
				if [[ "$line" =~ ([0-9a-f]+)"$OFF <$GREEN$symbol_name$OFF$PURPLE+0x$OFF$PURPLE"[0-9a-f]+"$OFF>" ]]; then
					target_address="${BASH_REMATCH[1]}"
					if [[ ! -v "labels[$target_address]" ]]; then
						labels["$target_address"]="$counter"
						counter="$((counter+1))"
					fi
				fi
			done
			need_newline_before_symbol=1

			for line in "${lines[@]}"; do
				if [[ "$line" == "..." ]]; then
					echo "$GRAY       │                                ..."
					continue
				fi

				[[ "$line" =~ ^([0-9a-f]+):[[:space:]]+([0-9a-f]{2}(\ [0-9a-f]{2})*)([[:space:]]*.*)$ ]]
				address="${BASH_REMATCH[1]}"
				asm_code="${BASH_REMATCH[2]}"
				insn="${BASH_REMATCH[4]}"

				label="${labels[$address]}"
				if [[ -n "$label" ]]; then
					label="$label:  "
					label="$RED${label:0:4}$BROWN"
				else
					label="    "
				fi

				if [[ "$insn" =~ ^(.*)"$PURPLE"([0-9a-f]+)"$OFF <$GREEN$symbol_name$OFF$PURPLE+0x$OFF$PURPLE"[0-9a-f]+"$OFF>"(.*)$ ]]; then
					prefix="${BASH_REMATCH[1]}"
					target_address="${BASH_REMATCH[2]}"
					suffix="${BASH_REMATCH[3]}"
					target_label="${labels[$target_address]}"
					insn="$prefix$RED$target_label$OFF$suffix"
				elif [[ "$insn" =~ ^(.*)"$PURPLE"[0-9a-f]+"$OFF <$GREEN"(.*)"$OFF>"(.*)$ ]]; then
					prefix="${BASH_REMATCH[1]}"
					target_symbol="${BASH_REMATCH[2]}"
					suffix="${BASH_REMATCH[3]}"
					insn="$prefix$GREEN$target_symbol$OFF$suffix"
				elif [[ "$insn" =~ ^(.*)"[${BLUE}rip$OFF".*"]"(.*)"# "[^\<]**"<"(.*)">"$ ]]; then
					prefix="${BASH_REMATCH[1]}"
					suffix="${BASH_REMATCH[2]}"
					target_symbol="${BASH_REMATCH[3]}"
					if [[ "$target_symbol" =~ ^(.*)([+-]"0x"[0-9a-f]+)$ ]]; then
						target_symbol="${BASH_REMATCH[1]}$PURPLE${BASH_REMATCH[2]}"
					fi
					insn="$prefix$BROWN[${ORANGE}rel$OFF $GREEN$target_symbol$BROWN]$suffix"
				else
					insn="${insn// [/ $BROWN[}"
					insn="${insn//:[/ $BROWN[}"
					insn="${insn//]/$BROWN]}"
				fi

				if [[ "$insn" =~ ^(.*[^@])(@[A-Za-z0-9_.@]+)(.*)$ ]]; then
					insn="${BASH_REMATCH[1]}$DARKGREEN${BASH_REMATCH[2]}$GREEN${BASH_REMATCH[3]}"
				fi

				insn="${insn//ZMMWORD PTR /${ORANGE}zmmword$OFF }"
				insn="${insn//YMMWORD PTR /${ORANGE}ymmword$OFF }"
				insn="${insn//XMMWORD PTR /${ORANGE}xmmword$OFF }"
				insn="${insn//MMWORD PTR /${ORANGE}mmword$OFF }"
				insn="${insn//QWORD PTR /${ORANGE}qword$OFF }"
				insn="${insn//DWORD PTR /${ORANGE}dword$OFF }"
				insn="${insn//FWORD PTR /${ORANGE}fword$OFF }"
				insn="${insn//WORD PTR /${ORANGE}word$OFF }"
				insn="${insn//TBYTE PTR /${ORANGE}tbyte$OFF }"
				insn="${insn//BYTE PTR /${ORANGE}byte$OFF }"

				if [[ -z "$insn" ]]; then
					address=""
				fi

				# This has to be present even if we want to use the same color for (bad) as we use
				# for other instructions, because for some reason objdump spuriously fails to color
				# (bad)
				insn="${insn//(bad)/$RED(bad)$OFF}"

				insn="${insn//,/, }"
				insn="${insn//,  /, }"

				printf "$GRAY%6s │ $BROWN%s%s%s\n" "$address" "$label" "$asm_code" "$insn"
			done
		elif [[ "$line" =~ ^"Disassembly of section "(.*):$ ]]; then
			section="${BASH_REMATCH[1]}"
			printf "$GRAY───────┼$BAR\n"
			printf "$GRAY       │$OFF Section $RED%s\n" "$section"
			printf "$GRAY───────┼$BAR"
			need_newline_before_symbol=0
		fi
	done

	echo "$GRAY───────┴$BAR"
} \
| less -R
