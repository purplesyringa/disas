#!/usr/bin/env bash
ESC=$'\x1b'
GRAY="$ESC[38;5;238m"
BROWN="$ESC[38;2;117;113;94m"
RED="$ESC[38;2;249;38;114m"
LIGHTGREEN="$ESC[38;2;166;226;46m"
ORANGE="$ESC[38;2;237;145;17m"
BLUE="$ESC[38;2;0;170;255m"
PURPLE="$ESC[38;2;205;49;222m"
GREEN="$ESC[38;2;49;181;49m"
DARKGREEN="$ESC[38;2;29;69;40m"
BOLD="$ESC[1m"
OFF="$ESC[0m"


syntax=intel
path=
noopt=0

for arg in "$@"; do
	handle_path=0
	if [[ $noopt -eq 0 ]]; then
		case "$arg" in
		--intel)
			syntax=intel
			;;
		--att)
			syntax=att
			;;
		--)
			noopt=1
			;;
		-*)
			echo "Unknown option $arg" >&2
			exit 1
			;;
		*)
			handle_path=1
		esac
	else
		handle_path=1
	fi

	if [[ $handle_path -eq 1 ]]; then
		if [[ -n "$path" ]]; then
			echo "Multiple files cannot be disassembled simultaneously" >&2
			exit 1
		fi

		path="$arg"
		if [[ ! -e "$path" ]]; then
			path="$(which "$arg")"
			if [[ -z "$path" ]]; then
				line="$(ldconfig -p | grep -P "^\t$arg(\.\d+)* \(" | head -1)"
				if [[ "$line" =~ ^.*" => "(.*)$ ]]; then
					path="${BASH_REMATCH[1]}"
				else
					echo "disas: $arg: not found"
					exit 1
				fi
			fi
		fi
	fi
done

if [[ -z "$path" ]]; then
	echo "Usage:"
	echo "disas <options...> <file>"
	echo
	echo "Supported options:"
	echo "--intel             Use Intel syntax (default)"
	echo "--att               Use AT&T syntax"
	exit 1
fi


objdump_opts=()

if [[ "$syntax" == "intel" ]]; then
	objdump_opts+=(-Mintel)
elif [[ "$syntax" == "att" ]]; then
	objdump_opts+=(-Matt)
fi


BAR="$(yes | tr -d "\n" | head -c $(($(tput cols) - 8)) | sed s/y/─/g)"

objdump \
	--disassemble \
	--disassembler-color=color \
	--demangle \
	"${objdump_opts[@]}" \
	"$path" \
| {
	read -r line
	read -r line
	file_format="$(<<<"$line" sed "s/.*file format //")"
	printf "$GRAY───────┬$BAR\n"
	printf "$GRAY       │$OFF Disassembly: $BOLD%s$OFF $BROWN(%s)\n" "$path" "$file_format"

	need_newline_before_symbol=0

	while read -r line; do
		if [[ "$line" =~ ^[0-9a-f]{16}\ \<(.*)\>:$ ]]; then
			if [[ $need_newline_before_symbol -eq 1 ]]; then
				echo "$GRAY       │"
			fi

			symbol_name="${BASH_REMATCH[1]}"

			if [[ "$symbol_name" =~ ^(.*[^@])(@[A-Za-z0-9_.@]+)(.*)$ ]]; then
				symbol_name="${BASH_REMATCH[1]}$DARKGREEN${BASH_REMATCH[2]}$LIGHTGREEN${BASH_REMATCH[3]}"
			fi
			if [[ "$symbol_name" =~ ^(.*)([+-]"0x"[0-9a-f]+)$ ]]; then
				symbol_name="${BASH_REMATCH[1]}$PURPLE${BASH_REMATCH[2]}"
			fi
			printf "$GRAY       │ $LIGHTGREEN%s$OFF\n" "$symbol_name"

			declare -A labels
			lines=()
			counter=1
			while read -r line && [[ -n "$line" ]]; do
				line="${line//$ESC[32m/$GREEN}"
				line="${line//$ESC[33m/$ORANGE}"
				line="${line//$ESC[34m/$BLUE}"
				line="${line//$ESC[35m/$PURPLE}"

				lines+=("$line")
				if [[ "$line" =~ ^([0-9a-f]+):.*[^0-9a-f]([0-9a-f]+)"$OFF <$GREEN$symbol_name$OFF$PURPLE+0x$OFF$PURPLE"[0-9a-f]+"$OFF>" ]]; then
					source_address="${BASH_REMATCH[1]}"
					target_address="${BASH_REMATCH[2]}"
					if [[ "$source_address" != "$target_address" && ! -v "labels[$target_address]" ]]; then
						labels["$target_address"]="$counter"
						counter="$((counter+1))"
					fi
				fi
			done
			need_newline_before_symbol=1

			for line in "${lines[@]}"; do
				if [[ "$line" == "..." ]]; then
					echo "$GRAY       │                                ..."
					continue
				fi

				[[ "$line" =~ ^([0-9a-f]+):[[:space:]]+([0-9a-f]{2}(\ [0-9a-f]{2})*)([[:space:]]*.*)$ ]]
				address="${BASH_REMATCH[1]}"
				asm_code="${BASH_REMATCH[2]}"
				insn="${BASH_REMATCH[4]}"

				label="${labels[$address]}"
				if [[ -n "$label" ]]; then
					label="$label:  "
					label="$RED${label:0:4}$BROWN"
				else
					label="    "
				fi

				if [[ "$insn" =~ ^(.*)"$PURPLE"([0-9a-f]+)"$OFF <$GREEN$symbol_name$OFF$PURPLE+0x$OFF$PURPLE"[0-9a-f]+"$OFF>"(.*)$ ]]; then
					prefix="${BASH_REMATCH[1]}"
					target_address="${BASH_REMATCH[2]}"
					suffix="${BASH_REMATCH[3]}"
					target_label="${labels[$target_address]}"
					if [[ "$syntax" == intel ]]; then
						if [[ "$address" == "$target_address" ]]; then
							target_label="$"
						fi
					elif [[ "$syntax" == att ]]; then
						if [[ "$address" == "$target_address" ]]; then
							target_label="."
						elif [[ $((0x$target_address)) -gt $((0x$address)) ]]; then
							target_label="${target_label}f"
						else
							target_label="${target_label}b"
						fi
					fi
					insn="$prefix$RED$target_label$OFF$suffix"
				elif [[ "$insn" =~ ^(.*)"$PURPLE"[0-9a-f]+"$OFF <$GREEN"(.*)"$OFF>"(.*)$ ]]; then
					prefix="${BASH_REMATCH[1]}"
					target_symbol="${BASH_REMATCH[2]}"
					suffix="${BASH_REMATCH[3]}"
					insn="$prefix$GREEN$target_symbol$OFF$suffix"
				elif [[ "$insn" =~ ^(.*)"[${BLUE}rip$OFF".*"]"(.*)"# "[^\<]**"<"(.*)">"$ ]]; then
					# Intel style
					prefix="${BASH_REMATCH[1]}"
					suffix="${BASH_REMATCH[2]}"
					target_symbol="${BASH_REMATCH[3]}"
					if [[ "$target_symbol" =~ ^(.*)([+-]"0x"[0-9a-f]+)$ ]]; then
						target_symbol="${BASH_REMATCH[1]}$PURPLE${BASH_REMATCH[2]}"
					fi
					insn="$prefix$BROWN[${ORANGE}rel$OFF $GREEN$target_symbol$BROWN]$suffix"
				elif [[ "$insn" =~ ^(.*)"${PURPLE}0x"[0-9a-f]+"$OFF($BLUE%rip$OFF)"(.*)"# "[^\<]**"<"(.*)">"$ ]]; then
					prefix="${BASH_REMATCH[1]}"
					suffix="${BASH_REMATCH[2]}"
					target_symbol="${BASH_REMATCH[3]}"
					if [[ "$target_symbol" =~ ^(.*)([+-]"0x"[0-9a-f]+)$ ]]; then
						target_symbol="${BASH_REMATCH[1]}$PURPLE${BASH_REMATCH[2]}"
					fi
					insn="$prefix$GREEN$target_symbol$BROWN($BLUE%rip$BROWN)$OFF$suffix"
				else
					# [ -> $BROWN[ doesn't work because [ might be part of the CSI
					insn="${insn// [/ $BROWN[$OFF}"
					insn="${insn//:[/:$BROWN[$OFF}"
					insn="${insn//,[/,$BROWN[$OFF}"
					insn="${insn//]/$BROWN]$OFF}"
					insn="${insn//(/$BROWN($OFF}"
					insn="${insn//)/$BROWN)$OFF}"
				fi

				if [[ "$insn" =~ ^(.*[^@])(@[A-Za-z0-9_.@]+)(.*)$ ]]; then
					insn="${BASH_REMATCH[1]}$DARKGREEN${BASH_REMATCH[2]}$GREEN${BASH_REMATCH[3]}"
				fi

				insn="${insn//ZMMWORD PTR /${ORANGE}zmmword$OFF }"
				insn="${insn//YMMWORD PTR /${ORANGE}ymmword$OFF }"
				insn="${insn//XMMWORD PTR /${ORANGE}xmmword$OFF }"
				insn="${insn//MMWORD PTR /${ORANGE}mmword$OFF }"
				insn="${insn//QWORD PTR /${ORANGE}qword$OFF }"
				insn="${insn//DWORD PTR /${ORANGE}dword$OFF }"
				insn="${insn//FWORD PTR /${ORANGE}fword$OFF }"
				insn="${insn//WORD PTR /${ORANGE}word$OFF }"
				insn="${insn//TBYTE PTR /${ORANGE}tbyte$OFF }"
				insn="${insn//BYTE PTR /${ORANGE}byte$OFF }"

				if [[ -z "$insn" ]]; then
					address=""
				fi

				# This has to be present even if we want to use the same color for (bad) as we use
				# for other instructions, because for some reason objdump spuriously fails to color
				# (bad)
				insn="${insn//(bad)/$RED(bad)$OFF}"

				insn="${insn//,/, }"
				insn="${insn//,  /, }"

				printf "$GRAY%6s │ $BROWN%s%s%s\n" "$address" "$label" "$asm_code" "$insn"
			done
		elif [[ "$line" =~ ^"Disassembly of section "(.*):$ ]]; then
			section="${BASH_REMATCH[1]}"
			printf "$GRAY───────┼$BAR\n"
			printf "$GRAY       │$OFF Section $RED%s\n" "$section"
			printf "$GRAY───────┼$BAR"
			need_newline_before_symbol=0
		fi
	done

	echo "$GRAY───────┴$BAR"
} \
| less -R -F
